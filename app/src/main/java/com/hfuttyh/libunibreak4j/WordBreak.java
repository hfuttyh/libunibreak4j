package com.hfuttyh.libunibreak4j;import com.hfuttyh.libunibreak4j.WordBreakProperties.WordBreakClass;import java.util.Arrays;public class WordBreak {    public static final byte WORDBREAK_BREAK         = 0;   /**< Break is allowed */    public static final byte WORDBREAK_NOBREAK       = 1;   /**< No break is allowed */    public static final byte WORDBREAK_INSIDEACHAR   = 2;   /**< A UTF-8/16 sequence is unfinished */    /**     * Initializes the wordbreak internals.  It currently does nothing, but     * it may in the future.     */    void init_wordbreak()    {    }    /**     * Gets the word breaking class of a character.     *     * @param ch   character to check     * @param wbp  pointer to the wbp breaking properties array     * @return     the word breaking class if found; \c WBP_Any otherwise     */    private static WordBreakClass get_char_wb_class(int ch, WordBreakProperties[] wbp)    {        int len = wbp.length;        int min = 0;        int max = len - 1;        int mid;        do        {            mid = (min + max) / 2;            if (ch < wbp[mid].start)                max = mid - 1;            else if (ch > wbp[mid].end)                min = mid + 1;            else                return wbp[mid].prop;        }        while (min <= max);        return WordBreakClass.WBP_Any;    }    /**     * Sets the word break types to a specific value in a range.     *     * It sets the inside chars to #WORDBREAK_INSIDEACHAR and the rest to brkType.     * Assumes \a brks is initialized - all the cells with #WORDBREAK_NOBREAK are     * cells that we really don't want to break after.     *     * @param[in]  s             input string     * @param[out] brks          breaks array to fill     * @param[in]  posStart      start position     * @param[in]  posEnd        end position (exclusive)     * @param[in]  len           length of the string     * @param[in]  brkType       breaks type to use     * @param[in] get_next_char  function to get the next UTF-32 character     */    private static void set_brks_to(char[] s,                                    int[] brks,                                    int posStart,                                    int posEnd,                                    byte brkType)    {        int posNext = posStart;        while (posNext < posEnd)        {            int ch;            ch = UnibreakDef.lb_get_next_char_utf16(s, posNext);            posNext += UnibreakDef.lb_get_next_char_length(s, posNext);            assert(ch != UnibreakDef.EOS);            for (; posStart < posNext - 1; ++posStart)                brks[posStart] = WORDBREAK_INSIDEACHAR;            assert(posStart == posNext - 1);            /* Only set it if we haven't set it not to break before. */            if (brks[posStart] != WORDBREAK_NOBREAK)                brks[posStart] = brkType;            posStart = posNext;        }    }    /* Checks to see if the class is newline, CR, or LF (rules WB3a and b). */    private static boolean IS_WB3ab(WordBreakClass cls)    {        return ((cls == WordBreakClass.WBP_Newline) || (cls == WordBreakClass.WBP_CR) || (cls == WordBreakClass.WBP_LF));    }    /**     * Sets the word breaking information for a generic input string.     *     * @param[in]  s             input string     * @param[in]  len           length of the input     * @param[in]  lang          language of the input (reserved for future use)     * @param[out] brks          pointer to the output breaking data, containing     *                           #WORDBREAK_BREAK, #WORDBREAK_NOBREAK, or     *                           #WORDBREAK_INSIDEACHAR     * @param[in] get_next_char  function to get the next UTF-32 character     */    public static void set_wordbreaks(char[] s,                                       String lang,                                       int[] brks)    {        /* Counter of how many time we cam across RI */        int riCounter = 0;        WordBreakClass wbcLast = WordBreakClass.WBP_Undefined;        /* wbcSeqStart is the class that started the current sequence.         * WBP_Undefined is a special case that means "sot".         * This value is the class that is at the start of the current rule         * matching sequence. For example, in case of Numeric+MidNum+Numeric         * it'll be Numeric all the way.         */        WordBreakClass wbcSeqStart = WordBreakClass.WBP_Undefined;        int ch;        int posNext = 0;        int posCur = 0;        int posLast = 0;        /* TODO: Language-specific specialization. *///        (void) lang;        /* Init brks. */        Arrays.fill(brks, WORDBREAK_BREAK);        ch = UnibreakDef.lb_get_next_char_utf16(s, posNext);        posNext += UnibreakDef.lb_get_next_char_length(s, posNext);        while (ch != UnibreakDef.EOS)        {            WordBreakClass wbcCur;            wbcCur = get_char_wb_class(ch, WordBreakData.wb_prop_default);            switch (wbcCur)            {                case WBP_CR:                    /* WB3b */                    set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_LF:                    if (wbcSeqStart == WordBreakClass.WBP_CR) /* WB3 */                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                        break;                    }                    /* Fall through */                case WBP_Newline:                    /* WB3a,3b */                    set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_ZWJ:                case WBP_Extend:                case WBP_Format:                    /* WB4 - If not the first char/after a newline (WB3a,3b), skip                     * this class, set it to be the same as the prev, and mark                     * brks not to break before them. */                    if ((wbcSeqStart == WordBreakClass.WBP_Undefined) || IS_WB3ab(wbcSeqStart))                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                    }                    else                    {                        /* It's surely not the first */                        brks[posCur - 1] = WORDBREAK_NOBREAK;                        /* WB3c and WB3d precede 4, so no intervening Extend                         * chars allowed. */                        if (wbcCur != WordBreakClass.WBP_ZWJ && wbcSeqStart != WordBreakClass.WBP_ZWJ &&                                wbcSeqStart != WordBreakClass.WBP_WSegSpace)                        {                            /* "inherit" the previous class. */                            wbcCur = wbcLast;                        }                    }                    break;                case WBP_Katakana:                    if ((wbcSeqStart == WordBreakClass.WBP_Katakana) || /* WB13 */                            (wbcSeqStart == WordBreakClass.WBP_ExtendNumLet)) /* WB13b */                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                    }                    /* No rule found, reset */                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    }                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_Hebrew_Letter:                case WBP_ALetter:                    if ((wbcSeqStart == WordBreakClass.WBP_Hebrew_Letter) &&                            (wbcLast == WordBreakClass.WBP_Double_Quote)) /* WB7b,c */                    {                        if (wbcCur == WordBreakClass.WBP_Hebrew_Letter)                        {                            set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                        }                        else                        {                            set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        }                    }                    else if (((wbcSeqStart == WordBreakClass.WBP_ALetter) ||                            (wbcSeqStart == WordBreakClass.WBP_Hebrew_Letter)) || /* WB5,6,7 */                            (wbcLast == WordBreakClass.WBP_Numeric) || /* WB10 */                            (wbcSeqStart == WordBreakClass.WBP_ExtendNumLet)) /* WB13b */                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                    }                    /* No rule found, reset */                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    }                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_Single_Quote:                    if (wbcLast == WordBreakClass.WBP_Hebrew_Letter) /* WB7a */                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                    }                    /* Fall through */                case WBP_MidNumLet:                    if (((wbcLast == WordBreakClass.WBP_ALetter) ||                            (wbcLast == WordBreakClass.WBP_Hebrew_Letter)) || /* WB6,7 */                            (wbcLast == WordBreakClass.WBP_Numeric)) /* WB11,12 */                    {                        /* Go on */                    }                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                    }                    break;                case WBP_MidLetter:                    if ((wbcLast == WordBreakClass.WBP_ALetter) ||                            (wbcLast == WordBreakClass.WBP_Hebrew_Letter)) /* WB6,7 */                    {                        /* Go on */                    }                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                    }                    break;                case WBP_MidNum:                    if (wbcLast == WordBreakClass.WBP_Numeric) /* WB11,12 */                    {                        /* Go on */                    }                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                    }                    break;                case WBP_Numeric:                    if ((wbcSeqStart == WordBreakClass.WBP_Numeric) || /* WB8,11,12 */                            ((wbcLast == WordBreakClass.WBP_ALetter) ||                                    (wbcLast == WordBreakClass.WBP_Hebrew_Letter)) || /* WB9 */                            (wbcSeqStart == WordBreakClass.WBP_ExtendNumLet)) /* WB13b */                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                    }                    /* No rule found, reset */                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    }                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_ExtendNumLet:                    /* WB13a,13b */                    if ((wbcSeqStart == wbcLast) &&                            ((wbcLast == WordBreakClass.WBP_ALetter) ||                                    (wbcLast == WordBreakClass.WBP_Hebrew_Letter) ||                                    (wbcLast == WordBreakClass.WBP_Numeric) ||                                    (wbcLast == WordBreakClass.WBP_Katakana) ||                                    (wbcLast == WordBreakClass.WBP_ExtendNumLet)))                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                    }                    /* No rule found, reset */                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    }                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_Regional_Indicator:                    /* WB15,16 */                    if ((wbcSeqStart == WordBreakClass.WBP_Regional_Indicator) &&                            ((riCounter % 2) == 1))                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                        riCounter = 0; /* Reset the sequence */                    }                    /* No rule found, reset */                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        riCounter = 1;                    }                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                case WBP_Double_Quote:                    if (wbcLast == WordBreakClass.WBP_Hebrew_Letter) /* WB7b,c */                    {                        /* Go on */                    }                    else                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                        wbcSeqStart = wbcCur;                        posLast = posCur;                    }                    break;                case WBP_WSegSpace:                    if (wbcLast == WordBreakClass.WBP_WSegSpace) /* WB3d */                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                        posLast = posCur;                        break;                    }                    /* Fall through */                case WBP_Any:                    /* Check for rule WB3c */                    if (wbcLast == WordBreakClass.WBP_ZWJ && EmojiDef.ub_is_extended_pictographic(ch))                    {                        set_brks_to(s, brks, posLast, posCur, WORDBREAK_NOBREAK);                        posLast = posCur;                        break;                    }                    /* Allow breaks and reset */                    set_brks_to(s, brks, posLast, posCur, WORDBREAK_BREAK);                    wbcSeqStart = wbcCur;                    posLast = posCur;                    break;                default:                    /* Error, should never get here! */                    // assert(0);                    break;            }            wbcLast = wbcCur;            posCur = posNext;            ch = UnibreakDef.lb_get_next_char_utf16(s, posNext);            posNext += UnibreakDef.lb_get_next_char_length(s, posNext);        }        /* WB2 */        set_brks_to(s, brks, posLast, posNext, WORDBREAK_BREAK);    }}